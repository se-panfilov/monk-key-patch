{"version":3,"sources":["monkey-punch.js"],"names":["Monkey","config","console","error","body","linesDelimiter","isBefore","before","isAfter","after","_p","getLineNumber","key","trim","commaIndex","indexOf","substr","getColumnNumber","getColumnWeight","position","column","this","Infinity","compareColumns","a","b","sortNumberArr","arr","numberSort","sort","getStrArr","fn","fnArr","toString","split","splice","length","makeFn","originalFn","isEval","fnName","getFnName","fnStr","join","fnArgs","getParamNames","result","eval","Function","modifyBody","bodyConfig","positions","modifyAtPositions","regexps","modifyAtRegexp","injectAtLine","val","line","isNoColumn","slice","isIllegalKey","i","positionKey","positionsKeys","Object","keys","positionVal","wrapRegex","str","isWrapped","lastIndexOf","regexpObj","regex","hasOwnProperty","fnOrStr","match","matchesArr","exec","push","index","_match","replace","name","regexp","nameArr","STRIP_COMMENTS","ARGUMENT_NAMES","exports","modifiedFn","isLazy","punch","obj","method","self","arguments","returnValue","restore","original","isModified","clear","isClearOrigin","module"],"mappings":"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","file":"monkey-punch.min.js","sourcesContent":["var Monkey = (function (config) {\n  'use strict';\n\n  if (!config) console.error('Error: no config');\n\n  config.body.linesDelimiter = config.body.linesDelimiter || '\\n';\n\n  var isBefore = !!config.before;\n  var isAfter = !!config.after;\n\n  var _p = {\n    getLineNumber: function (key) {\n      key = key.trim();\n      var commaIndex = key.indexOf(',');\n      if (commaIndex === -1) return +key;\n      return +key.substr(0, key.indexOf(','));\n    },\n    getColumnNumber: function (key) {\n      key = key.trim();\n      var commaIndex = key.indexOf(',');\n      if (commaIndex === -1) return null;\n      return +key.substr(key.indexOf(',') + 1);\n    },\n    // getColumnAsDecimal: function (column) {\n    //   if (!column && column !== 0) return 0.00999999999;\n    //\n    //   var result;\n    //   var isLower = column < 0;\n    //\n    //   if (isLower) {\n    //     column *= -1;\n    //     result = '0.00' + column;\n    //   } else {\n    //     result = '0.' + column;\n    //   }\n    //\n    //   // if (isLower) result *= -1;\n    //\n    //   return +result;\n    // },\n    getColumnWeight: function (position) {\n      var column = this.getColumnNumber(position);\n      if (!column && column !== 0) return -Infinity;\n      return column;\n    },\n    compareColumns: function (a, b) {\n      if (a < 0 && a > -Infinity && b < 0 && b > -Infinity) {\n        return a - b\n      }\n      return b - a\n    },\n    sortNumberArr: function (arr) {\n      var numberSort = function (a, b) {\n        if (_p.getLineNumber(a) === _p.getLineNumber(b)) {\n          return _p.compareColumns(_p.getColumnWeight(a), _p.getColumnWeight(b));\n        } else {\n          return _p.getLineNumber(b) - _p.getLineNumber(a)\n        }\n      };\n\n      return arr.sort(numberSort);\n    },\n    getStrArr: function (fn, linesDelimiter) {\n      var fnArr = fn.toString().split(linesDelimiter);\n      //TODO (S.Panfilov) check this for one-liner\n      // Remove first line: \"function (a) {\"\n      fnArr.splice(0, 1);\n      // Remove last line: \"}\"\n      fnArr.splice(fnArr.length - 1, 1);\n      return fnArr;\n    },\n    makeFn: function (fnArr, originalFn, linesDelimiter, isEval) {\n      var fnName = this.getFnName(originalFn);\n      var fnStr = fnArr.join(linesDelimiter);\n      var fnArgs = this.getParamNames(originalFn);\n      var result;\n\n      if (!isEval) {\n        //this is for named function\n        if (fnName) fnStr = 'return function ' + fnName + ' () {' + fnStr + '};';\n\n        result = new Function(fnArgs, fnStr);\n      } else {\n        //TODO (S.Panfilov) debug this branch\n        //TODO (S.Panfilov) what about comma at the end?\n        result = eval('(function ' + fnName + '(' + fnArgs.toString + ') {' + fnStr + '})');\n      }\n      return result;\n    },\n    modifyBody: function (fnArr, bodyConfig) {\n      if (bodyConfig.positions)  fnArr = this.modifyAtPositions(fnArr, bodyConfig.positions);\n      if (bodyConfig.regexps)  fnArr = this.modifyAtRegexp(fnArr, bodyConfig.regexps);\n      return fnArr;\n    },\n    injectAtLine: function (arr, position, val) {\n      var line = this.getLineNumber(position);\n      var column = this.getColumnNumber(position);\n      var isNoColumn = !column && column !== 0;\n\n      //TODO (S.Panfilov) this should be in docs (we are trimming the lines)\n      arr[line] = arr[line].trim();\n\n      if (column > arr[line].length || isNoColumn) column = arr[line].length;\n\n      // if (column > 0) {\n      // arr.splice(line, 0, val);\n      // } else {\n      //TODO (S.Panfilov) here we inject the result of 'val()', but perhaps will be better to pass function here somehow\n      //TODO (S.Panfilov) the idea is to run val() when only modified function will be called\n      //TODO (S.Panfilov) and to have an ability to pass context here\n      //TODO (S.Panfilov) in this case would be a reason to call val's cb\n      if (typeof val === 'function') val = val();\n      arr[line] = arr[line].slice(0, column) + val + arr[line].slice(column);\n      // }\n\n      return arr;\n    },\n    isIllegalKey: function (arr, fnArr) {\n      var line;\n\n      for (var i = 0; i < arr.length; i++) {\n        var positionKey = arr[i];\n        line = this.getLineNumber(positionKey);\n        //TODO (S.Panfilov) add getColumnNumber() > cur line length (or trim line length)\n        if (line < 0 || line >= fnArr.length)  return true;//TODO (S.Panfilov) Cur work point\n      }\n\n      return false;\n    },\n    modifyAtPositions: function (fnArr, positions) {\n      var positionsKeys = this.sortNumberArr(Object.keys(positions));\n\n      if (this.isIllegalKey(positionsKeys, fnArr)) return console.error('Illegal key present');\n\n      for (var i = 0; i < positionsKeys.length; i++) {\n        var positionKey = positionsKeys[i];\n        var positionVal = positions[positionKey];\n        this.injectAtLine(fnArr, positionKey, positionVal);\n      }\n\n      return fnArr;\n    },\n    wrapRegex: function (str) {\n\n      //TODO (S.Panfilov) this woudn't work cause of '/g', '/i', etc. Should make new RegExp perhaps\n      var isWrapped = (str.indexOf('/') === 0 && str.lastIndexOf('/'));\n\n      return (isWrapped) ? str : ('/' + str + '/');\n    },\n    modifyAtRegexp: function (fnArr, regexpObj, linesDelimiter) {\n      var fnStr = fnArr.join(linesDelimiter);\n\n      for (var regex in regexpObj) {\n        if (regexpObj.hasOwnProperty(regex)) {\n          var fnOrStr = regexpObj[regex];\n          if (typeof fnOrStr === 'function') {\n            //(asd.toString()).search(/\\)\\n/g)\n            var match;\n            var matchesArr = [];\n            while ((match = regex.exec(fnStr)) !== null) {\n              matchesArr.push(match.index);\n            }\n\n            for (var i = 0; i < matchesArr.length; i++) {\n              var _match = matchesArr[i];\n              var positions = [{}];\n              positions[0][_match] = fnOrStr;\n              fnStr = (this.modifyAtPositions(this.getStrArr(fnStr), positions)).join(linesDelimiter);\n            }\n\n          } else { //string\n            fnStr.replace(this.wrapRegex(regex), fnOrStr);\n          }\n        }\n      }\n\n      return this.getStrArr(fnArr, config.body.linesDelimiter);\n    },\n    getFnName: function (fn) {\n      if (fn.name) return fn.name;\n\n      var regexp = /^function\\s+([\\w\\$]+)\\s*\\(/;\n      var nameArr = regexp.exec(fn.toString());\n      return (nameArr) ? nameArr[1] : null;\n    },\n    getParamNames: function (fn) {\n      var STRIP_COMMENTS = /(\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/)|(\\s*=[^,\\)]*(('(?:\\\\'|[^'\\r\\n])*')|(\"(?:\\\\\"|[^\"\\r\\n])*\"))|(\\s*=[^,\\)]*))/mg;\n      var ARGUMENT_NAMES = /([^\\s,]+)/g;\n\n      var fnStr = fn.toString().replace(STRIP_COMMENTS, '');\n      var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n\n      return result || [];\n    }\n  };\n\n  var exports = {\n    config: config,\n    originalFn: null,\n    modifiedFn: null,\n    linesDelimiter: config.body.linesDelimiter,\n    before: config.before,\n    after: config.after,\n    isLazy: false,\n    punch: function () {\n      this.originalFn = this.config.obj[this.config.method];\n\n      if (this.config.body) {\n        this.modifiedFn = this.config.obj[this.config.method];\n        var fnArr = _p.getStrArr(this.modifiedFn, this.linesDelimiter);\n        _p.modifyBody(fnArr, config.body);\n        this.modifiedFn = _p.makeFn(fnArr, this.originalFn, this.linesDelimiter);\n      }\n\n      if (!this.before && !this.after) {\n        this.config.obj[this.config.method] = this.modifiedFn || this.originalFn;\n      } else {\n        var self = this;\n        this.config.obj[this.config.method] = function () {\n\n          if (isBefore) self.before(arguments);\n\n          var returnValue = (self.modifiedFn) ? self.modifiedFn(arguments) : self.originalFn(arguments);\n\n          if (isAfter) self.after(arguments);\n\n          return returnValue;\n        };\n      }\n\n      return this;\n    },\n    restore: function () {\n      config.obj[config.method] = this.original;\n      this.isModified = false;\n      return this;\n    },\n    clear: function (isClearOrigin) {\n      //TODO (S.Panfilov) clear monkey object, but stay patched\n      //Perhaps should save optional possibility to restore after clear\n      return this;\n    }\n  };\n\n  if (!exports.isLazy) return exports.punch();\n\n  return exports;\n});\n\n//Support of node.js\nif (typeof module === 'object' && module.exports) module.exports = Monkey;\n\n//TODO (S.Panfilov) Roadmap:\n// - Add support for one-liners\n// - Add \"punch\": ability to patch func again after restore was called\n// - Add \"Lazy\" option (do not patch immediately)\n// - Add ability to patch several methods at once (in arr of str)\n// - Add ability to use eval instead of new Func\n// - make sure column can be set up from the end (-1)\n// - Before and After should be called with same args as origin\n// - Check closures and globals in terms of new Func\n\n// var myMonkey = new Monkey({\n//   obj: patchTarget,\n//   method: ['sum', 'min'], //patch one (string) or several methods (array of str)\n//   before: doItBefore, //only function here\n//   after: doItAfter, // should be called with same args as origin\n//   isLazy: false, // lazy allow you to not patch immediately\n//   body: {\n//     linesDelimiter: '\\n',\n//     isEval: false, //option to use eval instead of new Function\n//     regexps: {\n//       '/\\)\\n/g': addSemiQuoteFn, // add ';' after each ')'\n//       '/\\{/g': ' ' // add space before each'{'\n//     },\n//     positions: {\n//       1: '// injection to line one',\n//       5: '// injection to line five',\n//       2: lineTwoInjectionFunc,\n//       '6,10': '// Injection to line 6 column 10',\n//       '2,3': lineTwoColumnThreeInjectionFunc,\n//       '2,-1': lineTwoColumnOneFromEndInjectionFunc\n//     }\n//   }\n// });\n\n// ...\n// myMonkey.restore();\n// ..."],"sourceRoot":"/source/"}