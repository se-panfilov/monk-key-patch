{"version":3,"sources":["monkey-punch.js"],"names":["Monkey","config","console","error","linesDelimiter","isBefore","before","isAfter","after","_p","override","cb","object","obj","method","log","getLineNumber","key","trim","commaIndex","indexOf","substr","getColumnNumber","sortNumberArr","arr","numberSort","a","b","this","sort","getStrArr","fn","fnArr","toString","split","splice","length","makeFn","fnName","getFnName","fnStr","join","fnArgs","getParamNames","Function","modifyBody","bodyConfig","positions","modifyAtPositions","regexps","modifyAtRegexp","injectLine","position","val","line","column","slice","positionsKeys","Object","keys","i","positionKey","positionVal","wrapRegex","str","isWrapped","lastIndexOf","regexpObj","regex","hasOwnProperty","fnOrStr","match","matchesArr","exec","push","index","_match","replace","name","regexp","nameArr","STRIP_COMMENTS","ARGUMENT_NAMES","result","exports","original","isModified","modifiedFnBody","isLazy","punch","apply","arguments","body","returnValue","restore","clear","isClearOrigin","module"],"mappings":"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","file":"monkey-punch.min.js","sourcesContent":["var Monkey = (function (config) {\n  'use strict';\n\n  if (!config) console.error('Error: no config');\n\n  config.linesDelimiter = config.linesDelimiter || '\\n';\n\n  //TODO (S.Panfilov) return errors for out of range\n  // if (config._maxLineKey > linesCount) {\n  //   console.error('Error: line number too big');\n  //   return;\n  // }\n  //\n  // if (config._minLineKey <= 0) {\n  //   console.error('Error: line number too lower than 0');\n  //   return;\n  // }\n\n  var isBefore = !!config.before;\n  var isAfter = !!config.after;\n\n  var _p = {\n    override: function (cb) {\n      var object = config.obj;\n      var method = config.method;\n      object[method] = cb(object[method]);\n      console.log(1);\n    },\n    getLineNumber: function (key) {\n      key = key.trim();\n      var commaIndex = key.indexOf(',');\n      if (commaIndex === -1) return key;\n      return +key.substr(0, key.indexOf(','));\n    },\n    getColumnNumber: function (key) {\n      key = key.trim();\n      var commaIndex = key.indexOf(',');\n      if (commaIndex === -1) return 0;\n      return +key.substr(key.indexOf(',') + 1);\n    },\n    sortNumberArr: function (arr) {\n      var numberSort = function (a, b) {\n        return this.getLineNumber(a) > this.getLineNumber(b)\n      };\n\n      return arr.sort(numberSort);\n    },\n    getStrArr: function (fn, linesDelimiter) {\n      var fnArr = fn.toString().split(linesDelimiter);\n      //TODO (S.Panfilov) check this for one-liner\n      // Remove first line: \"function (a) {\"\n      fnArr.splice(0, 1);\n      // Remove last line: \"}\"\n      fnArr.splice(fnArr.length - 1, 1);\n      return fnArr;\n    },\n    makeFn: function (fnArr, linesDelimiter) {\n      var fnName = this.getFnName(config.method);\n      var fnStr = fnArr.join(linesDelimiter);\n      var fnArgs = this.getParamNames(config.method);\n\n      //this is for named function\n      if (fnName) fnStr = 'return function ' + fnName + ' () {' + fnStr + '};';\n      return new Function(fnArgs, fnStr);\n    },\n    modifyBody: function (bodyConfig) {\n      var fnArr = this.getStrArr(config.obj[config.method], config.linesDelimiter);\n\n      if (bodyConfig.positions)  fnArr = this.modifyAtPositions(fnArr, bodyConfig.positions);\n      if (bodyConfig.regexps)  fnArr = this.modifyAtRegexp(fnArr, bodyConfig.regexps);\n      return fnArr;\n    },\n    injectLine: function (arr, position, val) {\n      var line = this.getLineNumber(position);\n      var column = this.getColumnNumber(position);\n\n      if (column > arr[line].length) column = arr.length;\n\n      if (column > 0) {\n        arr.splice(line, 0, val);\n      } else {\n        arr[line] = arr[line].slice(0, column) + val + arr[line].slice(column);\n      }\n\n      return arr;\n    },\n    modifyAtPositions: function (fnArr, positions) {\n      var positionsKeys = this.sortNumberArr(Object.keys(positions));\n\n      for (var i = positionsKeys.length - 1; i >= 0; i--) {\n        var positionKey = positionsKeys[i];\n        var positionVal = positions[positionsKeys];\n        //TODO (S.Panfilov) cur work point\n        this.injectLine(fnArr, positionKey, positionVal);\n      }\n\n      return fnArr;\n    },\n    wrapRegex: function (str) {\n\n      //TODO (S.Panfilov) this woudn't work cause of '/g', '/i', etc. Should make new RegExp perhaps\n      var isWrapped = (str.indexOf('/') === 0 && str.lastIndexOf('/'));\n\n      return (isWrapped) ? str : ('/' + str + '/');\n    },\n    modifyAtRegexp: function (fnArr, regexpObj, linesDelimiter) {\n      var fnStr = fnArr.join(linesDelimiter);\n\n      for (var regex in regexpObj) {\n        if (regexpObj.hasOwnProperty(regex)) {\n          var fnOrStr = regexpObj[regex];\n          if (typeof fnOrStr === 'function') {\n            //(asd.toString()).search(/\\)\\n/g)\n            var match;\n            var matchesArr = [];\n            while ((match = regex.exec(fnStr)) != null) {\n              matchesArr.push(match.index);\n            }\n\n            for (var i = 0; i < matchesArr.length; i++) {\n              var _match = matchesArr[i];\n              var positions = [{}];\n              positions[0][_match] = fnOrStr;\n              fnStr = (this.modifyAtPositions(this.getStrArr(fnStr), positions)).join(linesDelimiter);\n            }\n\n          } else { //string\n            fnStr.replace(this.wrapRegex(regex), fnOrStr);\n          }\n        }\n      }\n\n\n      return this.getStrArr(fnArr, config.linesDelimiter);\n\n    },\n    getFnName: function (fn) {\n      if (fn.name) return fn.name;\n\n      var regexp = /^function\\s+([\\w\\$]+)\\s*\\(/;\n      var nameArr = regexp.exec(fn.toString());\n      return (nameArr) ? nameArr[1] : null;\n    },\n    getParamNames: function (fn) {\n      var STRIP_COMMENTS = /(\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/)|(\\s*=[^,\\)]*(('(?:\\\\'|[^'\\r\\n])*')|(\"(?:\\\\\"|[^\"\\r\\n])*\"))|(\\s*=[^,\\)]*))/mg;\n      var ARGUMENT_NAMES = /([^\\s,]+)/g;\n\n      var fnStr = fn.toString().replace(STRIP_COMMENTS, '');\n      var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n\n      return result || [];\n    }\n  };\n\n  var exports = {\n    config: config,\n    original: null,\n    linesDelimiter: config.linesDelimiter,\n    before: config.before,\n    after: config.after,\n    isModified: false,\n    modifiedFnBody: null,\n    isLazy: false,\n    punch: function () {\n      //TODO (S.Panfilov) refactor work with override\n      \n      _p.override(function (original) {\n        exports.original = original;\n        return function () {\n          this.isModified = true;\n          if (isBefore) this.before.apply(this, arguments);\n          if (config.body) {\n            var fnArr = _p.modifyBody(config.body);\n            this.modifiedFnBody = fnArr.join(this.linesDelimiter);\n            original = _p.makeFn(fnArr, this.linesDelimiter)\n          }\n          var returnValue = original.apply(this, arguments);\n          if (isAfter) this.after.apply(this, arguments);\n\n          return returnValue;\n        }\n      });\n\n      return this;\n    },\n    restore: function () {\n      config.obj[config.method] = this.original;\n      this.isModified = false;\n      return this;\n    },\n    clear: function (isClearOrigin) {\n      //TODO (S.Panfilov) clear monkey object, but stay patched\n      //Perhaps should save optional possibility to restore after clear\n      return this;\n    }\n  };\n\n  if (!exports.isLazy) return exports.punch();\n\n  return exports;\n});\n\n//Support of node.js\nif (typeof module === 'object' && module.exports) module.exports = Monkey;\n\n//Roadmap:\n//TODO (S.Panfilov) Add support for one-liners\n//TODO (S.Panfilov) Add support for functions as well as strings in body params\n//TODO (S.Panfilov) add \"punch\": ability to patch func agaig after restore was called\n//TODO (S.Panfilov) Add \"Lazy\" option (do not patch immediately)\n\n// var myMonkey = new Monkey({\n//   obj: patchTarget,\n//   method: 'sum',\n//   linesDelimiter: '\\n',\n//   before: doItBefore,\n//   after: doItAfter,\n//   body: {\n//     regexps: {\n//       '/\\)\\n/g': addSemiQuoteFn, // add ';' after each ')'\n//       '/\\{/g': ' ' // add space before each'{'\n//     },\n//     positions: {\n//       1: '// injection to line one',\n//       5: '// injection to line five',\n//       2: lineTwoInjectionFunc,\n//       '6,10': '// Injection to line 6 column 10',\n//       '2,3': lineTwoColumnThreeInjectionFunc\n//     }\n//   }\n// });\n\n// ...\n// myMonkey.restore();\n// ..."],"sourceRoot":"/source/"}